<!DOCTYPE html>
<html>
    <head>
        <title>Hoist</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
        <script src="rough.js"></script>
        <script src="letters.js"></script>
<style>
@import url('https://fonts.googleapis.com/css?family=Montserrat+Subrayada|Roboto&display=swap');
h1 {
    font-family: 'Montserrat Subrayada', sans-serif;
    text-align: center;
    font-weight: normal;
    font-size: 300%;
}
canvas {
    border: 1px solid black;
    background-color: #f1f1f1;
    display: block;
    margin: auto;
}
p {
    font-family: 'Roboto', sans-serif;
    max-width: 800px;
    margin: auto;
    padding-top: 30px;
}
</style>
    </head>
    <body onload="startGame()">
        <h1>Hoist</h1>

        <canvas></canvas>

        <div>
    <p>
    <strong>Instructions:</strong> Tap the letter on your keyboard to grapple onto it and hoist yourself up.  Avoid the edges and survive for as long as you can.  Press space to pause.
    </p>
    <p>
    Thanks to the folks at <a href="https://roughjs.com/" target="_blank">rough.js</a> for their neat graphics library.
    </p>
        </div>
    <script>
var hoister;

function startGame() {
    hoister = new Hoister(30,"red",240,500);
    hoistArea.start();
}
var hoistArea = {
    canvas: document.getElementsByTagName("canvas")[0],
    start: function() {
        this.canvas.width = 480;
        this.canvas.height = 600;
        this.context = rough.canvas(this.canvas)
	    this.normalContext = this.canvas.getContext('2d');
        this.normalContext.font = "30px Arial";
        this.interval = 0;
        this.key = '';

        for (var i=0; i<hoistArea.canvas.height; i+=20) {
            spikeLines[0].push([0,i]);
            spikeLines[0].push([10,i+10]);
        }
        spikeLines[0].push([-10,hoistArea.canvas.height+10])
        for (var i=0; i<hoistArea.canvas.width; i+=20) {
            spikeLines[1].push([i, hoistArea.canvas.height]);
            spikeLines[1].push([i+10,hoistArea.canvas.height-10]);
        }
        spikeLines[1].push([hoistArea.canvas.width+10, hoistArea.canvas.height+10])
        for (var i=hoistArea.canvas.height; i>0; i-=20) {
            spikeLines[2].push([hoistArea.canvas.width,i]);
            spikeLines[2].push([hoistArea.canvas.width-10,i-10]);
        }
        spikeLines[2].push([hoistArea.canvas.width+10, -10])
        for (var i=hoistArea.canvas.width; i>0; i-=20) {
            spikeLines[3].push([i, 0]);
            spikeLines[3].push([i-10,10]);
        }
        spikeLines[3].push([-10,-10])

        window.addEventListener('keypress', function(e) {
            if (e.key == ' ') {
                if (hoistArea.interval) {
                    clearInterval(hoistArea.interval);
                    hoistArea.interval = 0;
                } else {
                    hoistArea.interval = setInterval(updateHoistArea, 20);
                }
            } else {
                if (hoistArea.interval)
                    hoistArea.key = e.key;
            }
        }, false)

        updateHoistArea();
    },
    clear: function() {
        this.normalContext.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
}
function Hoister(width, color, x, y) {
    this.width = width;
    this.x = x;
    this.y = y;
    this.v_x = 0;
    this.v_y = 0;
    this.gravity = 0;
    this.gravitySpeed = 0;
    this.update = function() {
        this.x += this.v_x;
        this.gravitySpeed += this.gravity;
        this.y += this.v_y + this.gravitySpeed;
        ctx = hoistArea.context;
        ctx.fillStyle = color;
        ctx.circle(this.x, this.y, this.width, { fill: "rgb(10,150,10)", fillWeight: 2, fillStyle: 'zigzag'});
        if (!this.gravity) {
            ctx.line(0, this.y+this.width/2, hoistArea.canvas.width, this.y+this.width/2)
        }

        if ((this.x - this.width/2 < 0) || (this.y - this.width/2 < 0) || (this.y + this.width/2 > hoistArea.canvas.height) || (this.x + this.width/2 > hoistArea.canvas.width)) {
            console.log('you lose');
            clearInterval(hoistArea.interval);
        }
    }
}
function letter(letter, x, y, direction) {
    this.letter = letter;
    this.x = x;
    this.y = y;
    this.update = function() {
        this.y += 1;
        if (this.y > hoistArea.canvas.height) {
            return false;
        }
        lettersDraw(hoistArea.context, this.letter, this.x, this.y, 30)
        return true;
    }
}
var frame = 0;
var spikeLines = [[],[],[],[]];
var letters = [];
var lettersChoice = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'];
function updateHoistArea() {
    if (lettersChoice.length) {
        if (Math.random() < .03) {
            var index = Math.floor(Math.random()*lettersChoice.length);
            var newLetter = lettersChoice[index];
            lettersChoice.splice(index, 1);
            letters.push(new letter(newLetter, Math.random()*hoistArea.canvas.width, 0, 2*Math.pi*Math.random()))
        }
    }
    hoistArea.clear();
    letters.forEach((letter) => {
        if (!letter.update()) {
            lettersChoice.push(letter.letter)
            letters.splice(letters.indexOf(letter), 1)
        } else {
            if(!hoister.gravity) {
                if (letter.y > hoister.y + hoister.width/2) {
                    hoister.gravity = .1;
                }
            }
        }
    });
    if (hoistArea.key) {
        var grappleLetter = letters.find(letter => letter.letter.toLowerCase() == hoistArea.key.toLowerCase());
        if (grappleLetter) {
            if (!hoister.gravity) {
                hoister.gravity = .1;
            }

            hoistArea.context.line(hoister.x, hoister.y, grappleLetter.x, grappleLetter.y, {roughness: 5, seed: 1});
            hoistArea.context.circle(grappleLetter.x, grappleLetter.y, 50, {fill: 'white', fillStyle: 'solid'});
            lettersDraw(hoistArea.context, grappleLetter.letter, grappleLetter.x, grappleLetter.y, 30);

            var dist_sq = ((hoister.x - grappleLetter.x)**2 + (hoister.y - grappleLetter.y)**2);
            hoister.v_x -= (hoister.x - grappleLetter.x) * 3 / Math.sqrt(dist_sq);
            hoister.v_y -= (hoister.y - grappleLetter.y) * 3 / Math.sqrt(dist_sq);
        }
        hoistArea.key = '';
    }
    // write score
    for (var i=0; i<(''+frame).length; i++) {
        lettersDraw(hoistArea.context, (''+frame)[i], 20+i*14, 23, 15)
    }
    hoister.update();
    // draw spikes on edge
    hoistArea.context.polygon(spikeLines[0], {fill: 'rgb(69,39,142)', fillStyle: 'solid', stroke: 'rgb(238,33,74)'});
    hoistArea.context.polygon(spikeLines[1], {fill: 'rgb(69,39,142)', fillStyle: 'solid', stroke: 'rgb(238,33,74)'});
    hoistArea.context.polygon(spikeLines[2], {fill: 'rgb(69,39,142)', fillStyle: 'solid', stroke: 'rgb(238,33,74)'});
    hoistArea.context.polygon(spikeLines[3], {fill: 'rgb(69,39,142)', fillStyle: 'solid', stroke: 'rgb(238,33,74)'});
    frame += 1;
}
    </script>
    </body>
</html>
