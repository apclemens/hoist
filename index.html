<!DOCTYPE html>
<html>
    <head>
        <title>Hoist</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
        <script src="rough.js"></script>
        <script src="letters.js"></script>
<style>
@import url('https://fonts.googleapis.com/css?family=Montserrat+Subrayada|Roboto&display=swap');
h1 {
    font-family: 'Montserrat Subrayada', sans-serif;
    text-align: center;
    font-weight: normal;
    font-size: 300%;
}
canvas {
    border: 1px solid black;
    background-color: #f1f1f1;
    display: block;
    margin: auto;
}
p {
    font-family: 'Roboto', sans-serif;
    max-width: 800px;
    margin: auto;
    padding-top: 30px;
}
</style>
    </head>
    <body onload="startGame()">
        <h1>Hoist</h1>

        <canvas></canvas>

        <div>
    <p>
    <strong>Instructions:</strong> Tap the letter on your keyboard to grapple onto it and hoist yourself up.  Avoid the edges and survive for as long as you can.  Press space to pause.
    </p>
    <p>
    Thanks to the folks at <a href="https://roughjs.com/" target="_blank">rough.js</a> for providing a team of animators to painstakingly hand draw each frame in real time.
    </p>
        </div>
    <script>
var hoister;

function startGame() {
    hoister = new Hoister(30,"red",240,500);
    hoistArea.start();
}
var hoistArea = {
    canvas: document.getElementsByTagName("canvas")[0],
    start: function() {
        this.canvas.width = 480;
        this.canvas.height = 600;
        this.context = rough.canvas(this.canvas)
	    this.normalContext = this.canvas.getContext('2d');
        this.normalContext.font = "30px Arial";
        this.interval = 0;
        this.key = '';
        this.message = ['SPACE TO START'];
        this.gameOver = false;

        for (var i=10; i<hoistArea.canvas.height; i+=20) {
            spikeLines[0].push([0,i]);
            spikeLines[0].push([10,i+10]);
        }
        spikeLines[0].push([-10,hoistArea.canvas.height+10])
        for (var i=10; i<hoistArea.canvas.width; i+=20) {
            spikeLines[1].push([i, hoistArea.canvas.height]);
            spikeLines[1].push([i+10,hoistArea.canvas.height-10]);
        }
        spikeLines[1].push([hoistArea.canvas.width+10, hoistArea.canvas.height+10])
        for (var i=hoistArea.canvas.height-10; i>0; i-=20) {
            spikeLines[2].push([hoistArea.canvas.width,i]);
            spikeLines[2].push([hoistArea.canvas.width-10,i-10]);
        }
        spikeLines[2].push([hoistArea.canvas.width+10, -10])
        for (var i=hoistArea.canvas.width-10; i>0; i-=20) {
            spikeLines[3].push([i, 0]);
            spikeLines[3].push([i-10,10]);
        }
        spikeLines[3].push([-10,-10])

        window.addEventListener('keypress', function(e) {
            if (e.key == ' ') {
		    e.preventDefault();
                if (hoistArea.gameOver) {
                    hoister = new Hoister(30,"red",240,500);
                    hoistArea.gameOver = false;
                    hoistArea.interval = setInterval(updateHoistArea, 20);
                    hoistArea.message = '';
                    letters = [];
                    frame = 0;
                    lettersChoice = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'];
		    numbersChoice = ['1','2','3','4','5','6','7','8','9','0'];
                } else {
                    if (hoistArea.interval) {
                        hoistArea.message = ['PAUSED', 'SPACE TO CONTINUE'];
                        clearInterval(hoistArea.interval);
                        updateHoistArea();
                        hoistArea.interval = 0;
                    } else {
                        hoistArea.interval = setInterval(updateHoistArea, 20);
                        hoistArea.message = '';
                    }
                }
            } else {
                if (hoistArea.interval)
                    hoistArea.key = e.key;
            }
        }, false)
        updateHoistArea();
    },
    clear: function() {
        this.normalContext.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
}
function Hoister(width, color, x, y) {
    this.width = width;
    this.x = x;
    this.y = y;
    this.v_x = 0;
    this.v_y = 0;
    this.gravity = 0;
    this.gravitySpeed = 0;
    this.update = function() {
        this.x += this.v_x;
        this.gravitySpeed += this.gravity;
        this.y += this.v_y + this.gravitySpeed;
        ctx = hoistArea.context;
        ctx.fillStyle = color;
        ctx.circle(this.x, this.y, this.width, { fill: "rgb(10,150,10)", fillWeight: 2, fillStyle: 'zigzag'});
        if (!this.gravity) {
            ctx.line(0, this.y+this.width/2, hoistArea.canvas.width, this.y+this.width/2)
        }

        if ((this.x - this.width/2 < 0) || (this.y - this.width/2 < 0) || (this.y + this.width/2 > hoistArea.canvas.height) || (this.x + this.width/2 > hoistArea.canvas.width)) {
            hoistArea.message = ['GAME OVER', 'SPACE TO RESTART'];
            clearInterval(hoistArea.interval);
            hoistArea.gameOver = true;
        }
    }
}
function Letter(letter, x, y, direction, speed) {
    this.letter = letter;
    this.x = x;
    this.y = y;
	this.speed = speed;
    this.update = function() {
        this.y -= this.speed*Math.sin(direction);
        this.x += this.speed*Math.cos(direction);
        if ((this.x < 0) || (this.y < 0) || (this.y > hoistArea.canvas.height) || (this.x > hoistArea.canvas.width)) {
            return false;
        }
	    lettersDraw(hoistArea.context, this.letter, this.x, this.y, 30, {})
        return true;
    }
}
var frame = 0;
var spikeLines = [[],[],[],[]];
var letters = [];
var createLetterFunction;
var decideToCreateLetter;
var lettersChoice = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'];
var numbersChoice = ['1','2','3','4','5','6','7','8','9','0'];
function updateHoistArea() {
	if (frame == 0) {
		chooseLetter = function() {
		    var index = Math.floor(Math.random()*lettersChoice.length);
		    var newLetter = lettersChoice[index];
		    lettersChoice.splice(index, 1);
			return newLetter;
		}
		createLetterFunction = function(frame) {
			var newLetter = chooseLetter();
		    return new Letter(newLetter, .5*hoistArea.canvas.width, 0, 3/2*Math.PI, 1)
		}
		decideToCreateLetter = function(frame) {
			return lettersChoice.length && frame % 100 == 1;
		}
	}
	if (frame == 500) {
		createLetterFunction = function(frame) {
			var newLetter = chooseLetter();
		    return new Letter(newLetter, Math.random()*hoistArea.canvas.width, 0, 3/2*Math.PI, 1)
		}
		decideToCreateLetter = function(frame) {
			return lettersChoice.length && frame % 50 == 1;
		}
	}
	if (frame == 1000) {
		decideToCreateLetter = function(frame) {
			return lettersChoice.length && Math.random() < .03;
		}
	}
	if (frame == 1500) {
		createLetterFunction = function(frame) {
							  var newLetter = chooseLetter();
			if (Math.random() < .5) {
							  // bottom up
		    return new Letter(newLetter, Math.random()*hoistArea.canvas.width, hoistArea.canvas.height, 1/2*Math.PI, .5+Math.random())
			} else {
							  // top down
		    return new Letter(newLetter, Math.random()*hoistArea.canvas.width, 0, 3/2*Math.PI, 1)
			}
		}
	}
	if (frame == 2000) {
		createLetterFunction = function(frame) {
							  var newLetter = chooseLetter();
		    return new Letter(newLetter, Math.random()*hoistArea.canvas.width, hoistArea.canvas.height, 1/2*Math.PI, .5+Math.random())
		}
	}
	if (frame == 3000) {
		createLetterFunction = function(frame) {
							  var newLetter = chooseLetter();
			    var rand = Math.random();
				if (rand < .25) {
			    return new Letter(newLetter, Math.random()*hoistArea.canvas.width, 0, Math.PI + Math.PI*Math.random(), .5+Math.random())
				} else if (rand < .5) {
			    return new Letter(newLetter, 0, Math.random()*hoistArea.canvas.height, 3/2*Math.PI + Math.PI*Math.random(), .5+Math.random())
				} else if (rand < .75) {
			    return new Letter(newLetter, Math.random()*hoistArea.canvas.width, hoistArea.canvas.height, Math.PI*Math.random(), .5+Math.random())
				} else {
			    return new Letter(newLetter, hoistArea.canvas.width, Math.random()*hoistArea.canvas.height, 1/2*Math.PI + Math.PI*Math.random(), .5+Math.random())
				}
		}
		decideToCreateLetter = function(frame) {
			return lettersChoice.length && Math.random() < .06;
		}
	}
	if (frame == 50000) {
		hoistArea.message = ['NUMBERS WHY NOT'];
		chooseLetter = function() {
		    var index = Math.floor(Math.random()*numbersChoice.length);
		    var newLetter = numbersChoice[index];
		    numbersChoice.splice(index, 1);
			return newLetter;
		}
		decideToCreateLetter = function(frame) {
			return numbersChoice.length && Math.random() < .06;
		}
	}
	if (frame == 50050) {
		hoistArea.message = [];
	}
if (decideToCreateLetter(frame)) {
	letters.push(createLetterFunction(frame));
}
    hoistArea.clear();
    letters.forEach((letter) => {
        if (!letter.update()) {
		if (Number(letter.letter))
            numbersChoice.push(letter.letter)
		else
            lettersChoice.push(letter.letter)
            letters.splice(letters.indexOf(letter), 1)
        } else {
            if(!hoister.gravity) {
                if (letter.y > hoister.y + hoister.width/2) {
                    hoister.gravity = .1;
                }
            }
        }
    });
    if (hoistArea.key) {
        var grappleLetter = letters.find(letter => letter.letter.toLowerCase() == hoistArea.key.toLowerCase());
        if (grappleLetter) {
            if (!hoister.gravity) {
                hoister.gravity = .1;
            }

            var dist_sq = ((hoister.x - grappleLetter.x)**2 + (hoister.y - grappleLetter.y)**2);

            hoistArea.context.line(hoister.x, hoister.y, grappleLetter.x, grappleLetter.y, {roughness: 5, stroke: 'green'});
            hoistArea.context.circle(grappleLetter.x, grappleLetter.y, 50, {fill: 'white', fillStyle: 'solid', stroke: 'green'});
            lettersDraw(hoistArea.context, grappleLetter.letter, grappleLetter.x, grappleLetter.y, 30, {stroke: 'green'});

            hoister.v_x -= (hoister.x - grappleLetter.x) * 3 / Math.sqrt(dist_sq);
            hoister.v_y -= (hoister.y - grappleLetter.y) * 3 / Math.sqrt(dist_sq);
        }
        hoistArea.key = '';
    }
    // write score
    for (var i=0; i<(''+frame).length; i++) {
        lettersDraw(hoistArea.context, (''+frame)[i], 20+i*14, 23, 15, {strokeWidth: .7})
    }
    hoister.update();
    // draw spikes on edge
    hoistArea.context.polygon(spikeLines[0], {fill: 'rgb(69,39,142)', fillStyle: 'solid', stroke: 'rgb(238,33,74)'});
    hoistArea.context.polygon(spikeLines[1], {fill: 'rgb(69,39,142)', fillStyle: 'solid', stroke: 'rgb(238,33,74)'});
    hoistArea.context.polygon(spikeLines[2], {fill: 'rgb(69,39,142)', fillStyle: 'solid', stroke: 'rgb(238,33,74)'});
    hoistArea.context.polygon(spikeLines[3], {fill: 'rgb(69,39,142)', fillStyle: 'solid', stroke: 'rgb(238,33,74)'});

    // write message
    if (hoistArea.message) {
        hoistArea.message.forEach((message, index) => {
            for (var i=0; i<message.length; i++) {
                lettersDraw(hoistArea.context, message[i], i*35*.74 + hoistArea.canvas.width/2 - (message.length-1)*35*.74/2, 55 + index*48, 35, {stroke: 'red', strokeWidth: 3})
            }
        })
    }
    frame += 1;
}
    </script>
    </body>
</html>
